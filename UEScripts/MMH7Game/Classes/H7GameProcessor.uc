//=============================================================================
// H7GameProcessor
//=============================================================================
// Handles all the combat calculations in a battle.
//=============================================================================
// Copyright 2013-2015 Limbic Entertainment All Rights Reserved.
//=============================================================================
class H7GameProcessor extends Object
	dependson(H7StructsAndEnumsNative)
	native;

var protected H7CombatResult        mLastAttackResult; // because fkn buffs override last result when they expire (those lil shits)

var protected H7CombatResult        mCurrentProcessingResult;
var protected int					mCurrentProcessingID;

var protected H7CombatResult        mMainResult;
var protected int					mCurrentProcessingMainID;

var protected H7UnitSnapShot        mCurrentAttackerSnapshot;

/** In case you don't want any results generated by auras, expiring buffs or other non-lethal actions. */
function H7CombatResult GetLastAttackResult()	{ return mLastAttackResult; }

function H7CombatResult GetCurrentResult()		{ return mCurrentProcessingResult; }
function H7CombatResult GetMainResult()		    { return mMainResult; }

function int			GetCurrentResultId()	    { return mCurrentProcessingID; }
function int			GetCurrentResultMainId()	{ return mCurrentProcessingMainID; }

native function AddTriggeredEffectToMainResult(H7Effect triggeredEffect);

function Init()
{
	mCurrentProcessingResult = new() class'H7CombatResult';
	mCurrentAttackerSnapshot = new class'H7UnitSnapShot';
}

// action needs to have values
// result can be empty
function bool ResolveCombat( out H7CombatResult result, bool forecast, bool isMainResult=false)
{
	local int i;
	local bool done;
	local H7EventContainerStruct container;
	local H7IEffectTargetable target;
	local H7ICaster caster, originalCaster;

	container.Result = result;
	result.ClearTriggeredEffects();
	result.GetCurrentEffect().GetTagsPlusBaseTags( container.ActionTag );
	container.ActionSchool = result.GetCurrentEffect().GetSource().GetSchool();
	container.EffectContainer = result.GetAttacker().GetOriginal().GetPreparedAbility();
	if( container.EffectContainer == none )
	{
		container.EffectContainer = result.GetCurrentEffect().GetSource();
	}

	if(result.GetActionId() == ACTION_RETALIATE)
	{
		container.Action = ACTION_RETALIATE;
	}
	else if(result.GetActionId() == ACTION_DOUBLE_MELEE_ATTACK)
	{
		container.Action = ACTION_DOUBLE_MELEE_ATTACK;
	}
	else if(result.GetActionId() == ACTION_DOUBLE_RANGED_ATTACK)
	{
		container.Action = ACTION_DOUBLE_RANGED_ATTACK;
	}
	else if (result.GetActionId() == ACTION_ABILITY)
	{
		container.Action = ACTION_ABILITY;
	}
	else if (result.GetActionId() == ACTION_LIGHTNING_REFLEXES_STRIKE)
	{
		container.Action = ACTION_LIGHTNING_REFLEXES_STRIKE;
	}
	else if( result.GetAttacker().GetOriginal().IsDefaultAttackActive()
		&& result.GetAttacker().GetEntityType() == UNIT_CREATURESTACK)
	{
		container.Action = result.GetAttacker().GetOriginal().GetPreparedAbility().IsRanged() ? ACTION_RANGE_ATTACK : ACTION_MELEE_ATTACK;
	}
	else
	{
		container.Action = ACTION_ABILITY;
	}
	
	if( isMainResult )
	{
		mMainResult = result;
		mMainResult.mIsForecast = forecast;
	}

	caster = result.GetAttacker();

	if( H7UnitSnapShot( caster ) != none )
		mCurrentAttackerSnapshot = H7UnitSnapShot( caster );
	else
		mCurrentAttackerSnapshot.TakeSnapShot( caster );

	;
	
	done = true;
	mCurrentProcessingResult = result;
	container.TargetableTargets = result.GetDefenders();
	mCurrentProcessingResult.mIsForecast = forecast;
	//`LOG_MP("Resolving combat for attacker: "@result.GetAttacker().GetOriginal().GetName()@"and defenders:"@result.GetDefenderCount());

	// creaturestacks and warunit
	originalCaster = mCurrentAttackerSnapshot.GetOriginal();
	;
	if( H7Unit( originalCaster ) != none && H7Unit( originalCaster ).GetCurrentLuckType() == GOOD_LUCK )
	{
		originalCaster.TriggerEvents( ON_DO_CRITICAL_HIT, forecast, container );
	}

	for( i=0; i<result.GetDefenderCount(); ++i )
	{
		mCurrentProcessingID = i;
		if(isMainResult) mCurrentProcessingMainID = i;

		container.Targetable = result.GetDefender(i);
		if(i==0) // events for the attacker are raised only for the first target (i.e. even if there are 5 defenders, attacker still only attacks once, move once, command once)
		{
			if( OnDoAttackRaiseCheck( result, i ) )
			{
				result.GetAttacker().GetOriginal().TriggerEvents( ON_DO_ATTACK, forecast, container );
			}
			
			

			
			if(forecast && isMainResult)
			{
				if( H7Unit( originalCaster ) != none )
					container.Path = H7Unit( originalCaster ).GetLastWalkedPath();
				result.GetAttacker().GetOriginal().TriggerEvents( ON_MOVE_ATTACK_START, forecast, container ); // TODO only raise if really will move
				result.GetAttacker().GetOriginal().TriggerEvents( ON_JUMP_PITCH, forecast, container ); // TODO only raise if really will move
				result.GetDefender(i).TriggerEvents( ON_TRIGGER_RETALIATION, forecast, container );
				result.GetDefender(i).TriggerEvents( ON_PRE_NEXT_COMMAND, forecast, container );
				result.GetDefender(i).TriggerEvents( ON_PRE_COMMAND, forecast, container );
				result.GetAttacker().GetOriginal().TriggerEvents( ON_PRE_COMMAND, forecast, container );
				result.GetAttacker().GetOriginal().TriggerEvents( ON_PRE_POST_COMMAND, forecast, container );
				result.GetAttacker().GetOriginal().TriggerEvents( ON_DO_DAMAGE, forecast, container );
				result.GetAttacker().GetOriginal().TriggerEvents( ON_POST_COMMAND, forecast, container );
				
				//mCurrentAttackerSnapshot.UpdateSnapShot( false, false );
			}
			else if(!forecast)
			{
				// awkward retaliation simulation to be able to check UseRetaliation correctly
				if(result.DoSendAttackEvent(i))
				{
					result.GetDefender().TriggerEvents( ON_TRIGGER_RETALIATION, true, container );
				}
			}
		}
		
		target = result.GetDefender(i);

		if( result.GetTriggerEvents( i ) )
		{
			// TODO all we know is that an effect goes to this unit, could be damage, could be buffeffect, etc. does not neccessarilrly have to be an attack at that point
			if((forecast && isMainResult) || !forecast)
			{
				if(result.DoSendAttackEvent(i))
				{
					target.TriggerEvents( ON_GET_ATTACKED, forecast, container );
				}
			}
			if(forecast && isMainResult) // TODO CHECK every defender gets a simulated pre and post event, but in reality only the main target gets one
			{
				target.TriggerEvents(ON_GET_TARGETED, forecast, container);
				// GUI Checks !!! to simulate Post/Pre Command events for tooltip
				target.TriggerEvents( ON_POST_COMMAND, forecast, container );
			}
			if( class'H7ReplicationInfo'.static.GetInstance().IsCombatMap() && !class'H7ReplicationInfo'.static.GetInstance().GetControllerManager().GetCombatController().IsInNonCombatPhase() )
			{
				if(result.DoSendAttackEvent(i))
				{
					class'H7CombatController'.static.GetInstance().RaiseEvent( ON_ANY_GET_ATTACKED, forecast );
				}
			}
		} 
		else
		{
			//`log_dui("not raising ON_GET_ATTACKED");
		}
		
		;

		if( ResolveCombatSingle( result, forecast, i , isMainResult) == false )
		{
			done = false;
			;
		}
	}

	result.DebugLogSelf();
	
	if(isMainResult)
	{
		//mMainResult = none;
		mCurrentProcessingMainID = -1;
		//mCurrentAttackerSnapshot.UpdateSnapShot( false, false );
	}

	return done;
}

protected function bool OnDoAttackRaiseCheck( H7CombatResult result, optional int idx=0 )
{
	local H7ICaster caster;
	local H7IEffectTargetable currentDefender;
	local H7Effect currentEffect;
	local H7BaseAbility abi;

	currentEffect = result.GetCurrentEffect();

	if( currentEffect == none ) return true;
	if(!result.DoSendAttackEvent( idx )) return false;
	// defender equals attacker? even if stuff suppresses abilities, do NOT raise that event
	caster = result.GetAttacker().GetOriginal();
	currentDefender = result.GetDefender( idx );
	if( currentDefender != none && Actor( caster ) == Actor( currentDefender ) ) return false;

	if( currentEffect.IsA('H7EffectWithSpells') )
	{
		if( H7EffectWithSpells( currentEffect ).GetData().mSpellStruct.mSpellOperation == UNSUPPRESS_ABILITY )
		{
			return false;
		}
	}

	// don't send attack event when defending/waiting
	if( H7CreatureStack( caster ) != none )
	{
		abi = caster.GetAbilityManager().GetAbility( H7CreatureStack( caster ).GetDefendAbility() );
		if( caster.GetAbilityManager().GetPreparedAbility() != none && caster.GetAbilityManager().GetPreparedAbility().IsEqual( abi ) )
		{
			return false;
		}

		abi = caster.GetAbilityManager().GetAbility( H7CreatureStack( caster ).GetWaitAbility() );
	}
	else if( H7EditorWarUnit( caster ) != none )
	{
		abi = caster.GetAbilityManager().GetAbility( H7EditorWarUnit( caster ).GetWaitAbility() );
	}

	if( abi != none )
	{
		if( caster.GetAbilityManager().GetPreparedAbility() != none && caster.GetAbilityManager().GetPreparedAbility().IsEqual( abi ) )
		{
			return false;
		}
	}

	if( result.GetContainer() != none && H7BaseAbility( result.GetContainer() ) != none && H7BaseAbility( result.GetContainer() ).IsPassive() )
	{
		if( H7CreatureStack( caster ) ==  none ) { return false; }

		// in case of fuckery like Strike & Return which is passive but active (trolololo)
		if( H7CreatureStack( caster ).GetMeleeAttackAbility() != none && H7BaseAbility( result.GetContainer() ).IsEqual( H7CreatureStack( caster ).GetMeleeAttackAbility() ) ||
			H7CreatureStack( caster ).GetRangedAttackAbility() != none && H7BaseAbility( result.GetContainer() ).IsEqual( H7CreatureStack( caster ).GetRangedAttackAbility() ) )
		{
			return true;
		}
		return false;
	}

	return true;
}

protected function CalculateDamage( out H7CombatResult result, int resultIdx, bool forecast )
{
	local float				    randomFloat;
	local float                 dmg, dmgLow, dmgHigh;
	local H7ICaster             attacker;

	attacker = result.GetAttacker().GetOriginal();

	dmg = 0.0f;

	result.UpdateDamageRange( resultIdx );


	dmgLow = result.GetDamageLow( resultIdx );
	dmgHigh = result.GetDamageHigh( resultIdx );

	if( H7Unit( attacker ) != none && H7EffectDamage( result.GetCurrentEffect() ) != none && H7EffectDamage( result.GetCurrentEffect() ).GetData().mUseMagicAbs )
	{
		dmg = FClamp( H7Unit( attacker ).GetModifiedStatByID( STAT_MAGIC_ABS ), 0.f, result.GetAttacker().GetMaximumDamage() * result.GetAttacker().GetStackSize() );
		result.SetDamageRange( dmg, dmg );
	}
	else
	{
		randomFloat = forecast ? FRand() : class'H7ReplicationInfo'.static.GetInstance().GetSynchRNG().GetRandomFloat();
		dmg  = Lerp( dmgLow, dmgHigh, randomFloat );
	}

	result.SetDamage( int(dmg), resultIdx );
}

// if 'forecast' is set to true the result will not be applied to the creature stacks' fight values
protected function bool ResolveCombatSingle( out H7CombatResult result, bool forecast, int resultIdx, bool isMainResult=false )
{
	local H7ICaster     		attackerUnit;
	local H7IEffectTargetable	defender;

	mCurrentProcessingResult = result;
	mCurrentProcessingID = resultIdx;
	if(isMainResult)
	{
		mCurrentProcessingMainID = resultIdx;
	}

	attackerUnit			= result.GetAttacker().GetOriginal();
	defender				= result.GetDefender( resultIdx );

	;


	// check for attacker
	if( attackerUnit == None )
	{
		;
		return false;
	}

	// check for defender
	if( defender == None )
	{
		;
		return false;
	}

	//if( !forecast )
	//{
	//	if( H7Unit( attackerUnit ) != none )
	//	{
	//		`LOG_MP("ATTACKER UNIT STAT MOD DUMP START"@attackerUnit.GetName());
	//		H7Unit( attackerUnit ).DumpModifiers();
	//		`LOG_MP("ATTACKER UNIT STAT MOD DUMP END"@attackerUnit.GetName());
	//	}
	//	if( H7Unit( defender ) != none )
	//	{
	//		`LOG_MP("DEFENDER UNIT STAT MOD DUMP START"@defender.GetName());
	//		H7Unit( defender ).DumpModifiers();
	//		`LOG_MP("DEFENDER UNIT STAT MOD DUMP END"@defender.GetName());
	//	}
	//}

	return MultiEffectAttack_X2C( result, forecast, resultIdx );
}

protected function ApplyDamage( H7CombatResult result, int resultIdx, bool isForecast, optional bool isRetaliation = false, optional H7IEffectTargetable target = none)
{
	if( target == none )
	{
		result.GetDefender(resultIdx).ApplyDamage( result, resultIdx, isForecast, isRetaliation );
	}
	else
	{
		target.ApplyDamage( result, resultIdx, isForecast , isRetaliation );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// NEW /////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

// WARNING - put attackpower and defensepower into the result first
// reduces min and max damage in the result accordingly
protected function ApplyPower( out H7CombatResult result, int resultIdx )
{
	local float					attackValue;
	local float					defenseValue;
	local float					attackModifier;
	local H7CombatConfiguration	combatConfig;
	local float	                cap;
	local H7ICaster	            caster;
	local H7IEffectTargetable	target;
	local H7TooltipMultiplier	current;

	combatConfig = class'H7CombatController'.static.GetInstance().GetCombatConfiguration();
	
	attackValue = result.GetAttackPower(); 
	defenseValue = result.GetDefensePower();
	caster = result.GetAttacker().GetOriginal();

	if( H7EffectDamage( result.GetCurrentEffect() ) != none &&
		H7EffectDamage( result.GetCurrentEffect() ).GetData().mUsePathLength && 
		H7CreatureStack( caster ) != none )
	{
		attackValue += H7EffectDamage( result.GetCurrentEffect() ).GetData().mMightBonusPerPathStep * H7CreatureStack( caster ).GetLastWalkedPathLength();
	}

	//The lowest cap of attack and defense is 0
	if(attackValue < 0)
	{
		attackValue = 0;
	}

	if(defenseValue < 0)
	{
		defenseValue = 0;
	}

	//`log_uss("PowerDiff" @ attackValue @ defenseValue);

	// calculate attack modifier
	if( attackValue > defenseValue )
	{
		//`log_uss("MIN(" @ combatConfig.MAX_ATTACK_MODIFIER_CAP @ "," @ (1.0f + combatConfig.HIGHER_ATTACK_VALUE_SCALAR) @ "*" @ (attackValue-defenseValue));
		attackModifier = FMin(combatConfig.MAX_ATTACK_MODIFIER_CAP, 1.0f + combatConfig.HIGHER_ATTACK_VALUE_SCALAR * (attackValue-defenseValue));
	}
	else if( attackValue == defenseValue )
	{
		attackModifier = 1.0f;
	}
	else
	{
		attackModifier = FMax( combatConfig.MIN_ATTACK_MODIFIER_CAP, 1.0f + combatConfig.LOWER_ATTACK_VALUE_SCALAR * (attackValue-defenseValue));
	}

	
	if( H7CreatureStack( caster ) != none && result.GetActionId() != ACTION_RETALIATE && result.GetActionId() != ACTION_RANGED_RETALIATE )
	{
		cap = H7CreatureStack( caster ).GetAttackPowerRelation( false );
		if( attackModifier < cap )
		{
			attackModifier = cap;
		}
	}

	target = result.GetDefender();
	if( H7CreatureStack( target ) != none && result.GetActionId() != ACTION_RETALIATE && result.GetActionId() != ACTION_RANGED_RETALIATE )
	{
		cap = H7CreatureStack( target ).GetAttackPowerRelation( true );
		if( attackModifier > cap && cap != 0.0f )
		{
			attackModifier = cap;
		}
	}
	
	// warfare units love this multiplier, so check if there is already one;
	// if yes, remove the old one, then add the new
	if( H7WarUnit( caster ) != none )
	{
		current = result.GetMultiplier( MT_ATT_DEF_POINT_DIFF, resultIdx );
		if( current.type == MT_ATT_DEF_POINT_DIFF )
		{
			result.RemoveMultiplier( MT_ATT_DEF_POINT_DIFF, resultIdx );
		}
	}

	result.AddMultiplier( MT_ATT_DEF_POINT_DIFF, attackModifier, resultIdx );
}

// reduces min and max damage in the result accordingly - by adding a modifier to the calculation array
protected function ApplyResistance( out H7CombatResult result, int resultIdx )
{
	local array<ESpellTag>          effectTags,spellTags,allTags;
	local ESpellTag                 tag;
	local float damageMultiplier;
	
	// collect a tag list of what the attack is:
	// tags of effect
	effectTags = result.GetCurrentEffect().GetTags();
	// tags of spell
	if(result.GetCurrentEffect().GetSource().IsA('H7BaseAbility'))
	{
		spellTags = H7BaseAbility(result.GetCurrentEffect().GetSource()).GetTags();
	}
	else if(result.GetCurrentEffect().GetSource().IsA('H7BaseBuff'))
	{
		spellTags = H7BaseBuff(result.GetCurrentEffect().GetSource()).GetTags();
	}
	else if(result.GetCurrentEffect().GetSource().IsA('H7HeroItem'))
	{
		// array stays empty
	}
	else
	{
		;
	}

	allTags = effectTags;
	foreach spellTags(tag)
	{
		allTags.AddItem(tag);
	}
	
	// sometimes tooltips have no targets
	if( result.GetDefender() == none )
		return;

	damageMultiplier = result.GetDefender(resultIdx).GetResistanceModifierFor(result.GetDamageSchool(resultIdx),allTags);

	if( damageMultiplier > 1 )
	{
		result.AddMultiplier( MT_VUL, damageMultiplier, resultIdx );
	}
	else if( damageMultiplier == 0 )
	{
		result.AddMultiplier( MT_IMMUNE, damageMultiplier, resultIdx );
	}
	else
	{
		result.AddMultiplier( MT_RESIST, damageMultiplier, resultIdx );
	}

	;
}

// checks effect.rank & effect.condition & effect.school&tags (which includes container.tags)
protected function bool CanApplyBuff(H7BaseBuff buff, H7IEffectTargetable defender, H7ICaster caster, H7EventContainerStruct container )
{
	return !class'H7EffectContainer'.static.TargetIsImmuneToAllExecutingEffectsOnArchetype( defender, caster, H7ICaster( defender ), caster, container, true, false, false, false, 0, buff, buff.GetTags(), buff.GetSchool() );
}

protected function ApplyMelee( out H7CombatResult result, int resultIdx, optional bool forecast )
{
	local float meleeModifier;
	local H7IEffectTargetable defender;
	local H7ICaster caster;
	local H7CombatConfiguration combatConfig;
	local H7EffectDamage damageEffect; 
	local H7BaseAbility baseablilty;
	local int distance;
	local H7EffectContainer source;

	
	;

	combatConfig = class'H7CombatController'.static.GetInstance().GetCombatConfiguration();

	if( result.GetAttacker().GetOriginal().IsA( 'H7CreatureStack' ) )
	{
		// determine melee modifier
		caster = result.GetAttacker().GetOriginal();
		if( H7CreatureStack( caster ).IsRanged() && H7CreatureStack( caster ).GetCreature().HasMeleePenalty() )
		{
			meleeModifier = combatConfig.MELEE_PENALTY_MODIFIER;
		}
		else
		{
			meleeModifier = 1.0f;
		}
		result.AddMultiplier( MT_MELEE, meleeModifier, resultIdx );

		source = result.GetCurrentEffect().GetSource();
		if( source != none && source.IsAbility() && H7BaseAbility( source ).GetTargetType() == TARGET_CONE )
		{
			if( result.GetCurrentEffect().IsA('H7EffectDamage') && result.GetDefender(resultIdx).isA('H7Unit') )
			{
				defender = result.GetDefender(resultIdx);
				damageEffect = H7EffectDamage( result.GetCurrentEffect() );
				// does this thing even have damage reduction? if not, don't bother and do not modify anything
				// (added this so marcus won't have to put a load of 1 modifiers on a bunch of cone targeting abilities)
				if(damageEffect.GetData().mDistanceDamageReduction.Length > 0 )
				{
					baseablilty = H7BaseAbility(  source );
					distance = class'H7CombatController'.static.GetInstance().GetGridController().GetDistanceTiles( H7Unit( caster ), H7Unit( defender ), forecast, baseablilty.GetConeRange() ) -1;
				
					if( damageEffect.GetData().mDistanceDamageReduction.Length > distance && distance >= 0)
					{
						result.AddMultiplier( MT_DISTANCE_MOD, damageEffect.GetData().mDistanceDamageReduction[distance], resultIdx );
					}
					else
					{
						result.AddMultiplier( MT_DISTANCE_MOD, 0 , resultIdx );
					}
				}
			}
		}
	}
}

protected function ApplyRanged( out H7CombatResult result, int resultIdx )
{
	local H7IEffectTargetable defender;
	local H7ICaster caster;
	local H7CombatConfiguration combatConfig;
	local H7EffectDamage effect;
	local array<H7CombatMapCell> coverCells;
	local bool isInCover;

	combatConfig = class'H7CombatController'.static.GetInstance().GetCombatConfiguration();

	;

	if( result.GetAttacker().GetOriginal().IsA( 'H7CreatureStack' ) )
	{
		defender = result.GetDefender( resultIdx );

		// cover system
		if( defender.IsA( 'H7CreatureStack' ) )
		{
			caster = result.GetAttacker().GetOriginal();
			class'H7CombatMapGridController'.static.GetInstance().ClearCurrentAttackPosition();
			coverCells = H7CreatureStack( defender ).GetCoverManager().GetCoverCells(H7CreatureStack(defender).GetCell());
			isInCover = H7CreatureStack( defender ).GetCoverManager().IsInCover( H7CreatureStack( caster ).GetCell().GetMergedCells(), coverCells );
			result.SetIsCovered( isInCover, resultIdx );
			effect = H7EffectDamage(result.GetCurrentEffect());
			if( result.IsCovered( resultIdx ) && ( effect == none || !effect.GetData().mIgnoreCover ) )
			{
				result.AddMultiplier( MT_COVER, class'H7CombatController'.static.GetInstance().GetCombatConfiguration().mCoverDamageReduction, resultIdx );
			}

			// determine ranged modifier
			if( H7CreatureStack( caster ).GetAttackRange() == CATTACKRANGE_FULL ||
				class'H7CombatMapGridController'.static.GetInstance().GetCombatGrid().UnitsInHalfRange( H7Unit( caster ), H7Unit( defender ) ) )
			{
				result.AddMultiplier( MT_RANGE, combatConfig.FULL_RANGE_MODIFIER, resultIdx );
			}
			else
			{
				result.AddMultiplier( MT_RANGE, combatConfig.HALF_RANGE_MODIFIER, resultIdx );
			}
		}
	}
}

// Spell Effect Attack (Buff,Debuff,Dispell,GiveAbility,RemoveAbility,SupressAbility,...)
// - Somebody attacks a creature with a H7EffectWithSpells
protected function bool SpellEffectAttack_X2C( out H7CombatResult result, bool forecast, int resultIdx )
{
	local H7EffectWithSpells         effect;
	local H7CreatureStack	         defenderCreatureStack;
	local ESpellOperation            operation;
	local H7Effectcontainer          effectContainer;
	local H7IEffectTargetable        defender;
	local H7ICaster                  caster;
	local EDefaultAbilities          defaultAbility;
	local H7EventContainerStruct     container;
	local H7HeroAbility              heroAbility;
	local array<ESpellTag>           tags;
	local H7UnitSnapShot             casterSnapShot;

	effect = H7EffectWithSpells(result.GetCurrentEffect());

	defender = result.GetDefender( resultIdx );


	defenderCreatureStack	  = H7CreatureStack( defender );

	// this only checks immunity to the effect
	effect.GetTagsPlusBaseTags(tags);
	if( defender.GetResistanceModifierFor( effect.GetSource().GetSchool() , tags ) == 0)
	{
		;
		return  false;
	}

	operation = effect.GetData().mSpellStruct.mSpellOperation;
	
	caster = result.GetAttacker().GetOriginal();
	if(!effect.RankCheck(caster)) // triple check? Was already checked in ExecuteSave and Execute, but I can arrive here without execute
	{
		;
		return false;
	}

	defaultAbility = effect.GetData().mSpellStruct.mDefaultAbility;
	switch( defaultAbility )
	{
		case ED_MELEE_ATTACK:
			effectContainer = defender.IsA('H7Unit') ? H7Unit( defender ).GetMeleeAttackAbility() : none;
			break;
		case ED_RANGED_ATTACK:
			effectContainer = defender.IsA('H7Unit') ? H7Unit( defender ).GetRangedAttackAbility() : none;
			break;
		case ED_WAIT_ABILITY:
			effectContainer = defender.IsA('H7Unit') ? H7Unit( defender ).GetWaitAbility() : none;
			break;
		case ED_DEFEND_ABILITY:
			effectContainer = defender.IsA('H7CreatureStack') ? H7CreatureStack( defender ).GetDefendAbility() : none;
			break;
		case ED_RETALIATION_ABILITY:
			effectContainer = defender.IsA('H7CreatureStack') ? H7CreatureStack( defender ).GetRetaliationAbility() : none;
			break;
		case ED_MORAL_ABILITY:
			effectContainer = defender.IsA('H7CreatureStack') ? H7CreatureStack( defender ).GetMoralAbility() : none;
			break;
		case ED_LUCK_ABILITY:
			effectContainer = defender.IsA('H7Unit') ? H7Unit( defender ).GetLuckAbility() : none;
			break;
		case ED_REPL_WARFARE_ATTACK:
		case ED_REPL_WARFARE_DEFAULT:
		case ED_REPL_WARFARE_SUPPORT:
			effectContainer = H7WarUnit( defender ) != none ? effect.GetData().mSpellStruct.mSpell : none;
			break;
		case ED_CUSTOM:
			effectContainer = effect.GetData().mSpellStruct.mSpell;
			break;
		case ED_REPL_MORAL_ABILITY:
		case ED_REPL_LUCK_ABILITY:
		default:
			effectContainer = effect.GetData().mSpellStruct.mSpell;
			break;
	}

	;


	// check if defender is immune to buffs/debuffs (only fully immune or not immune at all!)
	if(operation == ADD_BUFF && effectContainer != none && H7BaseBuff( effectContainer ) != none)
	{
		tags.Length = 0;
		tags = H7BaseBuff( effectContainer ).GetTags();
		if( defender.GetResistanceModifierFor( effectContainer.GetSchool(), tags, true) == 0.0f )
		{
			return false;
		}
	}
	

	
	switch(operation)
	{
		case ADD_BUFF:
			if(defender != none)
			{
				if( result.GetAttacker() != mCurrentAttackerSnapshot.GetOriginal() )
				{
					caster = result.GetAttacker();
					if( H7UnitSnapShot( caster ) != none ) casterSnapShot = H7UnitSnapShot( caster );
					else { casterSnapShot = new class'H7UnitSnapShot'; casterSnapShot.TakeSnapShot( caster ); }
				}
				else casterSnapShot = mCurrentAttackerSnapshot;
				if( CanApplyBuff( H7BaseBuff( effectContainer ), defender , casterSnapShot, container ) )
				{
					if( defenderCreatureStack != none )
					{
						defenderCreatureStack.ApplyBuff( result, resultIdx, forecast, casterSnapShot );
					}
					else
					{
						if( !forecast )
						{
							container.Result = result;
							container.Targetable = defender;
							container.EffectContainer = result.GetCurrentEffect().GetSource();
							result.GetCurrentEffect().GetTagsPlusBaseTags( container.ActionTag );

							defender.GetBuffManager().AddBuff( H7BaseBuff( effectContainer ), casterSnapShot, effect.GetSource() );
						}
					}
				}
				else
				{
					;
				}
			}
		break;
		case REMOVE_BUFF:
			if( !forecast )
			{
				defender.GetBuffManager().RemoveBuff( H7BaseBuff( effectContainer ), result.GetAttacker().GetOriginal() );
			}
		break;
		case ADD_ABILITY:
			if( !forecast )
			{
				// just use another template for Moral Buff
				if (defaultAbility == ED_REPL_MORAL_ABILITY && defender.GetEntityType() == UNIT_CREATURESTACK )
				{
					H7CreatureStack( defender ).SetSubstitutionMoraleAbility( H7BaseAbility( effectContainer )  );
				}
				if ( defaultAbility == ED_REPL_LUCK_ABILITY && defender.IsA('H7Unit') )
				{
					H7Unit( defender ).SetSubstituteLuckAbilty( H7BaseAbility( effectContainer ) );
				}

				// replace warfare unit abilities
				if( defender.IsA('H7WarUnit') )
				{
					if ( defaultAbility == ED_REPL_WARFARE_SUPPORT )
					{
						H7WarUnit( defender ).ReplaceSupportAbility( H7BaseAbility( effectContainer ) );
					}
					if ( defaultAbility == ED_REPL_WARFARE_DEFAULT )
					{
						H7WarUnit( defender ).ReplaceDefaultAbility( H7BaseAbility( effectContainer ) );
					}
					if ( defaultAbility == ED_REPL_WARFARE_ATTACK )
					{
						H7WarUnit( defender ).ReplaceAttackAbility( H7BaseAbility( effectContainer ) );
					}
				}


				// effectContainer is archetype, but that's ok for now
				if( H7HeroItem( effect.GetSource() ) != none )
				{
					defender.GetAbilityManager().LearnScrollSpell( H7BaseAbility( effectContainer ), effect.GetSource() );
				}
				else
				{
					heroAbility = H7HeroAbility( defender.GetAbilityManager().LearnAbility( H7BaseAbility( effectContainer ), effect.GetSource() ) );
					if( H7EditorHero( defender ) != none && heroAbility != none && effect.GetData().mSpellStruct.mAssociateWithSkill )
					{
						H7EditorHero( defender ).GetSkillManager().AddToLearnedAbilities( heroAbility );
					}
				}
			}
		break;
		case REMOVE_ABILITY:
			if( !forecast )
			{
				// effectContainer is archetype, but that's ok for now
				if( H7HeroItem( effect.GetSource() ) != none )
				{
					defender.GetAbilityManager().RemoveScrollSpell( H7BaseAbility( effectContainer ), effect.GetSource() , false );
					
				}
				else
				{
					heroAbility = H7HeroAbility( defender.GetAbilityManager().GetAbility( H7BaseAbility( effectContainer ) ) );
					if( H7EditorHero( defender ) != none && heroAbility != none && effect.GetData().mSpellStruct.mAssociateWithSkill )
					{
						H7EditorHero( defender ).GetSkillManager().RemoveFromLearnedAbilities( heroAbility );
					}
					defender.GetAbilityManager().UnlearnAbility( H7BaseAbility( effectContainer ) );

				}
			}
		break;
		case ADD_VOLABILITY:
			if( !forecast )
			{
				// effectContainer is archetype, but that's ok for now
				defender.GetAbilityManager().LearnVolatileAbility( H7BaseAbility( effectContainer ), effect.GetSource() );
			}
		break;
		case REMOVE_VOLABILITY:
			if( !forecast )
			{
				// effectContainer is archetype, but that's ok for now
				defender.GetAbilityManager().UnlearnVolatileAbility( H7BaseAbility( effectContainer ) );
			}
		break;
		case SUPPRESS_ABILITY:
			if( !forecast )
			{
				// effectContainer is archetype, but that's ok for now
				defender.GetAbilityManager().SuppressAbility( H7BaseAbility( effectContainer ) );
			}
			break;
		case UNSUPPRESS_ABILITY:
			if( !forecast )
			{
				// effectContainer is archetype, but that's ok for now 
				defender.GetAbilityManager().UnsuppressAbility( H7BaseAbility( effectContainer ) );
			}
			break;
		case INCREASE_SKILL:
			if( !forecast )
			{
				if( H7EditorHero( defender ) != none && H7Skill( effectContainer ) != none )
				{
					H7EditorHero( defender ).GetSkillManager().IncreaseSkillRankComplete( H7EditorHero( defender ).GetSkillManager().GetSkillInstance( , H7Skill( effectContainer ) ).GetID(), false, true );
				}
				else
				{
					;
				}
			}
			break;

		default:
			;
	}

	if( !forecast && class'H7ReplicationInfo'.static.GetInstance().IsCombatMap() && !class'H7CombatController'.static.GetInstance().IsSomeoneDying() )
	{
		class'H7CombatMapGridController'.static.GetInstance().RecalculateReachableCells(); // for feral charge, prepare&unprepare // OPTIONAL refactor to unit.MovementPointsChanged() && IAmSelected
	}

	return true;
}

protected function bool MultiEffectAttack_X2C( out H7CombatResult result, bool forecast, int resultIdx )
{
	local array<H7Effect> effects;
	local H7Effect effect;
	local H7ICaster attacker;
	local H7EventContainerStruct container;
	local H7EffectContainer source;
	local bool magicSynergy,hasAttackResult;

	;

	effects = result.GetEffects();
	attacker = result.GetAttacker().GetOriginal();
	;
	source = effects.Length > 0 ? effects[0].GetSource() : result.GetContainer();
	magicSynergy = false;
	hasAttackResult = false;

	foreach effects( effect )
	{
		;
		result.SetCurrentEffect(effect); // will be read by Effect Calculating sub function (DamageEffectAttack_X2C or SpellEffectAttack_X2C)
		magicSynergy = magicSynergy || effect.CheckMagicSynergy(attacker, result.GetDefender(resultIdx));

		if(effect.IsA('H7EffectDamage'))
		{
			DamageEffectAttack_X2C( result, forecast, resultIdx );
			if( !forecast && H7BaseAbility( source ) != none && !H7BaseAbility( source ).IsPassive() ) { mLastAttackResult = result; hasAttackResult = true; }
		}
		else if(effect.IsA('H7EffectWithSpells'))
		{
			SpellEffectAttack_X2C( result, forecast, resultIdx );
		}
		else if( effect.IsA('H7EffectSpecial' ) ) 
		{
			if( H7EffectSpecial(effect).DoesDamage() )
			{
				DamageEffectAttack_X2C( result, forecast, resultIdx );
				if( !forecast && H7BaseAbility( source ) != none && !H7BaseAbility( source ).IsPassive() ) { mLastAttackResult = result; hasAttackResult = true; }
			}
			else
			{
				;
			}
			
		}
		else
		{
			;
		}

		//mCurrentAttackerSnapshot.UpdateSnapShot( false, false );
	}

	// note: mLastAttackResult is _only_ used by ON_TRIGGER_RETALIATION (current result might hold buff expiration and screw up retaliation)
	if( !forecast && hasAttackResult ) { mLastAttackResult.SetAttacker( attacker ); }

	if(magicSynergy && effects.Length > 0 && !forecast)
	{
		container.Targetable = result.GetDefender();
		container.TargetableTargets = result.GetDefenders();
		container.Result = result;
		attacker.TriggerEvents(ON_MAGIC_SYNERGY_TRIGGERED,forecast,container); //GetEventManager().Raise(ON_MAGIC_SYNERGY_TRIGGERED, forecast, container);
	}

	return true;
}


function bool Calculate_EffectOnStats(out H7CombatResult result )
{
	local H7EffectOnStats effect;
	
	effect = H7EffectOnStats(result.GetCurrentEffect());

	if( effect.GetData().mStatMod.mUseSpellScaling )
	{
		SpellScalingEffetOnStat( result );
	}
	
	ApplyResistance( result, 0 );
	result.UpdateDamageRange();

	return true;
}

function bool Calculate_EffectDuration(out H7CombatResult result )
{
	local H7EffectDuration effect;
	
	effect = H7EffectDuration(result.GetCurrentEffect());

	if( effect.GetData().mUseSpellScaling )
	{
		SpellScalingEffetOnStat( result );
	}
	
	ApplyResistance( result, 0 );
	result.UpdateDamageRange();

	return true;
}

function ApplyMoral(out H7CombatResult result, int resultIdx )
{
	local H7BaseBuff moralBuff,penaltyBuff;
	local H7ICaster caster;
	local array<H7Effect> effects;
	local H7Effect effect;
	local float moralModifier;
	local H7Unit attackerUnit;
	
	;
	
	caster = result.GetAttacker().GetOriginal();
	attackerUnit = H7Unit(caster);
	// moralAbility

	// moralBuff
	moralBuff = class'H7BuffManager'.static.GetMoralBuff( attackerUnit );
	
	// penaltyBuff
	penaltyBuff = attackerUnit.GetBuffManager().GetBuff( moralBuff );
	
	if(penaltyBuff == none) return;

	// penalty
	penaltyBuff.GetEffects( effects, none );
	foreach effects(effect)
	{
		if(effect.IsA('H7EffectOnStats') && H7EffectOnStats(effect).GetData().mStatMod.mStat == STAT_MIN_DAMAGE )
		{
			moralModifier = H7EffectOnStats(effect).GetData().mStatMod.mModifierValue;
			// and then apply again via modifier:
			result.AddMultiplier(MT_MORAL,moralModifier,resultIdx);
		}
	}

}

// Damage Effect Attack
// - Somebody attacks a creature with a H7EffectDamage
// - attacker can be hero or creature (will be read from action)
protected function bool DamageEffectAttack_X2C( out H7CombatResult result, bool forecast, int resultIdx )
{
	local H7ICaster         attackerUnit;
	local H7CreatureStack	defenderCreatureStack;
	local H7Unit            defenderUnit;
	local H7EffectDamage    effect;
	local H7EffectSpecial   effectSpecial;
	local EAbilitySchool    school;
	local H7IEffectTargetable defender;
	local array<H7EffectSpecialShieldEffect> shieldeffects;
	local H7EffectSpecialShieldEffect shieldeffect;

	attackerUnit            = result.GetAttacker();

	defender = result.GetDefender( resultIdx );

	defenderCreatureStack = H7CreatureStack(defender);
	defenderUnit = H7Unit(defender);
	
	if ( result.GetCurrentEffect().IsA('H7EffectSpecial') )
	{
		effectSpecial = H7EffectSpecial( result.GetCurrentEffect() );
	}	
	else
	{
		effect = H7EffectDamage(result.GetCurrentEffect());
		;
	}

	

	result.SetDamageRange( result.GetBaseDamageRange().MinValue, result.GetBaseDamageRange().MaxValue, resultIdx );

	result.SetAttackPower(0);
	result.SetDefensePower(0);

	if( !attackerUnit.GetOriginal().IsA( 'H7WarUnit' ) && !attackerUnit.GetOriginal().IsA( 'H7TowerUnit' ) )
	{
		if( effectSpecial != none ) {  school = effectSpecial.GetSource().GetSchool(); }
		else                        {  school = effect.GetSource().GetSchool(); }
		
		if( H7UnitSnapShot( attackerUnit ) != none ) H7UnitSnapShot( attackerUnit ).UpdateSnapShot(true,true,!forecast);
		// override school if we should use unit school type
		if( effect != none )
		{
			if( effect.GetData().mUseDefaultSchool )
			{
				school = attackerUnit.GetOriginal().GetSchool();
			}
			else if( effect.GetData().mUseRandomSchool )
			{
				if( forecast )
				{
					school = EAbilitySchool( 1 + Rand( 7 ) );
				}
				else
				{
					school = EAbilitySchool( 1 + class'H7ReplicationInfo'.static.GetInstance().GetSynchRNG().GetRandomInt( 7 ) );
				}
			}
		}


		;
		
		// only creatures have moral and Heal doesnt trigger it
		if(attackerUnit.GetOriginal().IsA('H7CreatureStack') && !result.IsHeal(resultIdx) && result.GetActionId() != ACTION_RETALIATE )
		{
			ApplyMoral(result, resultIdx);
		}

		result.SetDamageSchool( school , resultIdx );

		if(effect != none && effect.GetData().mUseAttackPower)
		{
			result.SetAttackPower( attackerUnit.GetAttack() );
		}
		if(effect != none && effect.GetData().mUseDefensePower && defenderUnit != none )
		{
			result.SetDefensePower( defenderUnit.GetDefense() );
		}
		
		ApplyPower(result, resultIdx);
		//here wo go 

		if( ( effect != none && effect.GetData().mUseResist ) || ( effectSpecial != none && effectSpecial.GetData().mUseResist ) )
		{
			ApplyResistance( result, resultIdx );
		}
		
		if( result.GetActionId() == ACTION_MELEE_ATTACK || result.GetActionId() == ACTION_RETALIATE || result.GetActionId() == ACTION_LIGHTNING_REFLEXES_STRIKE )
		{
			ApplyMelee( result, resultIdx , forecast);
		}
		
		if( result.GetActionId() == ACTION_RANGE_ATTACK )
		{
			ApplyRanged( result, resultIdx );
		}
	}
	else if ( attackerUnit.GetOriginal().IsA( 'H7WarUnit' ) )
	{
		school = attackerUnit.GetOriginal().GetSchool();
		result.SetDamageSchool( school , resultIdx );

		H7WarUnit( attackerUnit ).ClearStatCache();

		if(effect != none && effect.GetData().mUseAttackPower)
		{
			result.SetAttackPower( attackerUnit.GetAttack() );
		}
		if(effect != none && effect.GetData().mUseDefensePower)
		{
			result.SetDefensePower( defenderCreatureStack.GetDefense() );
		}

		ApplyPower(result, resultIdx);
	
		if( ( effect != none && effect.GetData().mUseResist ) || ( effectSpecial != none && effectSpecial.GetData().mUseResist ) )
		{
			ApplyResistance( result, resultIdx );
		}
	}

	if( effect != none && effect.GetData().mUseSpellScaling && !result.IsConstDamageRange(resultIdx) )
	{
		SpellScalingDamage_NonStatic( result, resultIdx );
	}

	// everything was applied, now see what damage we actually do
	CalculateDamage( result, resultIdx, forecast );

	if( result.IsHeal(resultIdx) )
	{
		if( !forecast ) // heal can not deal with simulated
		{
			if( result.GetCurrentEffect().HasTag( TAG_RESURRECT ) )
			{
				if( defenderCreatureStack.CanBeResurrected() )
				{
					defenderCreatureStack.Resurrection( result.GetDamage( resultIdx ), defenderCreatureStack.IsDead() );
				}
			}
			else
			{
				defenderCreatureStack.Heal( result.GetDamage(resultIdx) );
			}
		}
		else
		{
			if( defenderCreatureStack.CanBeResurrected() )
			{
				defenderCreatureStack.Resurrection( result.GetDamage( resultIdx ), defenderCreatureStack.IsDead(), true, result, resultIdx, !result.GetCurrentEffect().HasTag( TAG_RESURRECT ) );
			}
		}
	}
	else
	{
		//Apply Shield if there's damage (THIS IS _NOT_ THE LEGIONNAIRE'S SHIELDING EFFECT! FFS)
		if( defenderUnit != none )
		{
			defenderUnit.GetAllShieldEffects( shieldeffects );
		}
		if( shieldeffects.Length > 0 )
		{
			foreach shieldeffects(shieldeffect)
			{
				shieldeffect.ApplyShield( result, resultIdx, forecast );
			}
		}

		ApplyDamage( result, resultIdx, forecast, result.GetActionId() == ACTION_RETALIATE );
	}

	return true;
}

protected function SpellScalingEffetOnStat( out H7CombatResult result ) 
{
	local H7ICaster hero;
	local H7EffectOnStats effect;

	// works only with hero because of the magic attribute
	if( !result.GetAttacker().GetOriginal().IsA('H7EditorHero') )
		return;

	if( !result.GetCurrentEffect().IsA('H7EffectOnStats'))
		return ;

	hero     =  result.GetAttacker();
	effect   =  H7EffectOnStats( result.GetCurrentEffect() );

	result.SetDamageRange( 0, SpellScaling( effect.GetData().mStatMod.mScalingModifierValue, hero) , 0 );	 	
}

protected function SpellScalingEffetDuration( out H7CombatResult result ) 
{
	local H7ICaster  hero;
	local H7EffectDuration effect;

	// works only with hero because of the magic attribute
	if( !result.GetAttacker().GetOriginal().IsA('H7EditorHero') )
		return;

	if( !result.GetCurrentEffect().IsA('H7EffectDuration'))
		return ;

	hero     =  result.GetAttacker();
	effect   =  H7EffectDuration( result.GetCurrentEffect() );

	result.SetDamageRange(0, SpellScaling( effect.GetData().mDurationScaling, hero), 0 );	 	
}

function SimulateDamageEffect( out H7CombatResult result, int resultIdx )
{
	if( mCurrentAttackerSnapshot == none || mCurrentAttackerSnapshot.GetOriginal() == none || mCurrentAttackerSnapshot.GetOriginal() != result.GetAttacker() )
	{
		mCurrentAttackerSnapshot.TakeSnapShot( result.GetAttacker() );
	}
	else
	{
		mCurrentAttackerSnapshot.UpdateSnapShot(false,false);
	}
	DamageEffectAttack_X2C( result, true, resultIdx );
}

/** Same as the static one but doesn't calculate a shitload of stuff. */
function SpellScalingDamage_NonStatic( out H7CombatResult result, int resultIdx )
{
	local H7ICaster  hero;
	local H7EffectDamage effect;

	// works only with hero because of the magic attribute
	if( !result.GetAttacker().GetOriginal().IsA('H7EditorHero') )
	{
		return;
	}

	if( !result.GetCurrentEffect().IsA('H7EffectDamage'))
	{
		return;
	}

	hero     =  result.GetAttacker();
	effect   =  H7EffectDamage( result.GetCurrentEffect() );

	if( effect.GetSource().IsA( 'H7BaseBuff' ) )
	{
		hero = effect.GetSource().GetCaster();
	}

	result.SetDamageRange(SpellScaling(effect.GetData().mMinDamage, hero), SpellScaling(effect.GetData().mMaxDamage, hero), resultIdx );
}

static function SpellScalingDamage( out H7CombatResult result, int resultIdx )
{
	local H7ICaster  hero;
	local H7EffectDamage effect;

	// works only with hero because of the magic attribute
	if( !result.GetAttacker().GetOriginal().IsA('H7EditorHero') )
	{
		return;
	}

	if( !result.GetCurrentEffect().IsA('H7EffectDamage'))
	{
		return;
	}

	hero     =  result.GetAttacker(); // can't use mCurrentAttackerSnapshot here since this function is static
	effect   =  H7EffectDamage( result.GetCurrentEffect() );

	result.SetDamageRange(SpellScaling(effect.GetData().mMinDamage, hero), SpellScaling(effect.GetData().mMaxDamage, hero), resultIdx );	 	
}


protected static function int SpellScaling( H7SpellScaling SpellScalingStruct, H7ICaster caster  )
{
	local int  value;


	value = ( SpellScalingStruct.mSlope * caster.GetMagic() ) + SpellScalingStruct.mIntercept;
    
	if( SpellScalingStruct.mUseCap )
		value = FMax( SpellScalingStruct.mMinCap, FMin( value, SpellScalingStruct.mMaxCap ) );

	return value;
}

native function bool WillSomeoneRetaliate(H7CombatResult containerResult);

function ClearResults()
{
	if( mMainResult != none )
	{
		mMainResult.ClearResult();
	}
	if( mCurrentProcessingResult != none )
	{
		mCurrentProcessingResult.ClearResult();
	}
	if( mLastAttackResult != none )
	{
		mLastAttackResult.ClearResult();
	}
}

